# CSAPP（第二版） 第二章习题解答

## 2.1 二进制《--》十六机制

### A.将0x39A7F8转换为二进制

>0x39A7F8
>
>0011 1001 1010 0111 1111 1000

### B. 二进制1100 1001 0111 1011转换为十六进制

>A 9 7 B

### C. 将0xD5E4C转换为二进制

>1101 0101 1110 0100 1100

### D. 将二进制10 0110 1110 0111 1011 0101转换为十六进制

> 补0: 0010 0110 1110 0111 1011 0101
>
> 转：2 6 E 7 B 5

## 2.2 二进制／十六进制表示

|  n   | $2^n$(十进制)     | $2^{n}$(十六进制) |
| :--: | :---------------- | ----------------- |
|  9   | 512               | 0x200             |
|  19  | 1028*512 = 524288 | 0x80000           |
|  14  | 16384             | 0x4000            |
|  16  | QwQ,不想算        | 0x10000           |
|  17  | 不想算            | 0x20000           |
|  5   | 32                | 0x20              |
|  7   | 128               | 0x80              |

**方法：** 当二进制表示为$2^n$次方时，十六进制如果可以写为$i+4j$，则十六进制可以写为  $0x2^i(\underbrace{0..0}_{j个0})$ 

以 $2^9$为例子，$9 = 2\times 4+1$,则可以表示为$0x200$

## 2.3 O$\Leftrightarrow$B$\Leftrightarrow$H

| 十进制 | 二进制    | 十六进制 |
| :----: | :-------- | :------: |
|   0    | 0000 0000 |   0x00   |
|  167   | 1100111   |   0x67   |
|   62   | 111100    |   0x3C   |
|  188   | 1111100   |   0x7C   |
|   55   | 0011 0111 |   0x37   |
|  136   | 1000 1000 |   0x88   |
|  243   | 1111 0011 |   0xF3   |
|   82   | 0101 0010 |   0x52   |
|  172   | 1010 1100 |   0xAC   |
|  251   | 1110 0111 |   0xE7   |

## 2.4 H 加法

> **Tip:** 将十进制加减法规则应用于16进制，仅需将基数改为16，加减法时也需要注意**满为16**

$$
\begin{aligned}
0x503c + 0x8 &= 0x5044 \\
0x503c - 0x40 &= 4ffc\\
0x503c + 64 &= 0x505c\\
0x50ea - 0x503c &= 0xad
\end{aligned}
$$

## 2.5 大端序／小端序  --- 对十六进制的word size输出

#### <1> prepare_way

```c
typedef unsigned char* pointer_char;
void show_bytes(pointer_char x, int len){
  for(int i=0; i<len; ++i){
    printf("%.2x", x[i]);
  }
}
```

#### <2> 大端序／小端序

> 目前的big-endian 只存在sun系统及互联网协议中，因此在socket通信中需要将big-endian-->little endian来通信

题目要求的是输出三次递增`1 2 3 `位的字长，则有：

| Big-Endian | Little-Endian |
| :--------: | :-----------: |
|     65     |      21       |
|   65 43    |     21 43     |
|  65 43 21  |   21 43 65    |

## 2.6 十六进制移位置匹配

> 因为机器不是sun的及浮点还没学，就不误导大家了qwq

## 2.7 char型调用

```c
show_bytes函数与2.5相同
```

输出结果为：

```c
"abcdefg"
 61 62 63 64 65 66 67
```

> 知：a～z的ascii码为0x61～0x7A

<font color=red>**Imp:**</font> ascii字符码在任何系统上的结果都是一样的，与word size||字节大小规则无关

## 2.8 Bool Algebra运算

| 运算 |    结果    |
| :--: | :--------: |
|  a   | [01101001] |
|  b   | [01010101] |
|  ~a  | [10010110] |
|  ~b  | [10101010] |
| a&b  | [01000001] |
| a\|b | [01111101] |
| a^b  | [00111100] |

>**可能疑惑：** 将逻辑运算视为set运算，关于**^**逻辑表示为**异或**（对称求解）

## 2.9 Log.补的运算

> 位向量(集合)间补的运算即为求反~[vec]

| R    | G    | B    | 颜色   | R    | G    | B    | 颜色   |
| ---- | ---- | ---- | ------ | ---- | ---- | ---- | ------ |
| 0    | 0    | 0    | 黑色   | 1    | 0    | 0    | 红色   |
| 0    | 0    | 1    | 蓝色   | 1    | 0    | 1    | 红紫色 |
| 0    | 1    | 0    | 绿色   | 1    | 1    | 0    | 黄色   |
| 0    | 1    | 1    | 蓝绿色 | 1    | 1    | 1    | 白色   |

### <1> 求八种颜色的补

> 求对应向量的反码后，根据表找到对应的补即可

### <2> 颜色运用布尔运算的结果

根据上述2.8的规则求也成了（我是懒doge）

## 2.10 异或的妙用

> 数电里也提到过，0 ^ [...] = [...], 1^[...] = ~[...]

根据程序：

```c
void replace(int *x, int *y){
	*y = *x^*y;
  *x = *x^*y;
  *y = *x^*y;
}
```

得：

|    Step     |       *x        |        *y         |
| :---------: | :-------------: | :---------------: |
| **Initial** |        a        |         b         |
| **Step 1**  |        a        |        a^b        |
| **Step 2**  | a^(a^b) = 0^b=b |        a^b        |
| **Step 3**  |        b        | b^(b^a) = 0^a = a |

## 2.11 数组颠倒

> 题目太长，我选择不抄（懒doge again

- A. First = [$\frac{2k+1}{2}$]+1, last. = [$\frac{2k+1}{2}$-1]
- B. 可以视为当数组指针到中位数（数组位置）时(a^a=0)-->(0^a=a)-->(a^a=0)这三个步骤
- C. 改为`first<last`

## 2.12 字节输出程序（little-debian）

> Requests:
>
> - 除了x的最低有效字节，其他都需要全为0；
> - 最低有效字节不变，其他的位取补
> - 最低有效字节设置为1，其他字节保持不变

 **一开始的做法错了，想用字节数组输出，但是这个好傻qwq，并且我没实现orz**

然后再看一遍题目，随机玩了玩移位，才感觉到这道题需要用的是**逻辑运算**...

```c
		int num = 0x87654321;
    /*A*/
    printf("%.8x\n", num&(0xFF));
    /*B*/
    printf("%.8x\n", num^(0x11111100));
    /*C*/
    printf("%.8x\n", num|(0x000000FF));
```

根据逻辑运算就可以得出啦

## 2.13 bis/bic 实现

> **要求：** 只能用逻辑运算，理解一下即bis把m为1的位置，z对应的位也设为1；bic则把m为1的位置，z设为0.最后用bis和bic实现|及^运算

```c
int bis(int x, int m){
    return x|m;
}

int bic(int x, int m){
    return x&(~m);
}
/*calculation of '|'*/
int bool_or(int x, int y){
    return bis(x, y);
}

/*calculation of '^'*/
int bool_xor(int x, int y){
    return bis(bic(x,y),bic(y,x));
}
```

**问题：**在一开始实现异或时没有考虑$x=0,m=1$的情况，如果只用bic来实现的话输出的仅为0，但实际应该是1

## 2.14 十六进制的运算

> 注意这里如果笔算，建议先将16进制转为二进制，进行集合的运算后能更快得到结果

|   表达式   |  值  |
| :--------: | :--: |
|   x & y    | 0x20 |
|   x \| y   | 0x7F |
|  ~x \| ~y  | 0xDF |
|   x & !y   | 0x00 |
|   x && y   | 0x01 |
|  x \|\| y  | 0x01 |
| !x \|\| !y | 0x00 |
|  x && ~y   | 0x01 |

**对应程序：**

```c
		int x = 0x66, y = 0x39;
    printf("x&y = %x\n", x&y);
    printf("x|y = %x\n", x|y);
    printf("~x|~y = %x\n", ~x|~y);
    printf("x&!y = %x\n", x&!y);
    printf("x&&y = %x\n", x&&y);
    printf("x||y = %x\n", x||y);
    printf("!x||!y = %x\n", !x||!y);
    printf("x&&~y=%x\n", x&&~y);
```

## 2.15 逻辑实现 x==y

> c语言通过位级和逻辑运算，判断x==y

**如果是这么实现，需要用到**`?x:x`来作最终判断

```c
int judgeEqual(int x, int y){
    return x&(~y);
}
```

**最直接的是：**

```c
cout << !(x^y) << endl;
```

## 2.16 B$\Leftrightarrow$H移位运算

> - 因为懒+目前gcc一般都位算数移位，所以逻辑的程序就没写了qwq

| x        |           | x<<3      |          | x>>2(逻辑) |          | x>>2(算术) |          |
| -------- | --------- | --------- | -------- | ---------- | -------- | ---------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制     | 十六进制 | 二进制     | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000  | 0x30     | 1111 0000  | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101  | 0x1D     | 0001 1101  | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001  | 0x21     | 1110 0001  | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001  | 0x19     | 0001 1001  | 0x19     |

> 然而我不知道为什么mac的移位显示的是逻辑移位...，迷惑

**实现程序：**

```c
void transfer(int x){
    cout << "choose move bytes:";
    int mv;
    //getchar();
    cin >> mv;
    switch (mv) {
        case 3:
            printf("Arith. %x << 3 = %x\n", x, x << 3);
            break;
        case 2:
            printf("Arith. %x >> 2 = %x\n", x, x >> 2);
            break;
        default:
            cout << "nothing input~" << endl;
            break;
    }
}
```

## 2.17 B2U B2T的转化

> 这个记得考虑符号位就没有什么问题啦～（我就不写啦～

## 2.18 H$\Leftrightarrow$D

> 在实现的过程中，发现cout输出的是十进制的数，cin同样只能处理十进制；
>
> scanf采用%x，和printf%对应进制就木有问题

```c
/*如果我没有理解错题意的话（小声），我会觉得这样就可以了*/
    while (1){
        scanf("%x", &sub);
        printf("%x --d--> %d\n", sub, sub);
    }
```

结果是这样的：

```bash
0x1b8 									/*A*/
1b8 --d--> 440
0x14 										/*B*/
14 --d--> 20
0xfffffe58 							/*C*/
fffffe58 --d--> -424
0XFFFFFE74 							/*D*/
fffffe74 --d--> -396
0x44 										/*E*/
44 --d--> 68
0x10 										/*F*/
10 --d--> 16
0xc 										/*G*/
c --d--> 12
0x8 										/*H*/
8 --d--> 8
0x20 										/*J*/
20 --d--> 32
0xfffffeec 							/*I*/
fffffeec --d--> -276
```

## 2.19 T2U

>把补码（`Two's Complement`）写出来，再转无符号会更加保险哦～（熟练直接出来也阔以了

|  x   | $T2U_{4}(x)$ |
| :--: | :----------: |
|  -8  |      8       |
|  -3  |      13      |
|  -2  |      14      |
|  -1  |      15      |
|  0   |      0       |
|  5   |      5       |

> 正数不变，t的负数的绝对值加无符号数和位$2^w$值【这个也是2.20的答案吧】

## 2.21 T U的比较

> t与u型比较时，会将t型强制转换为u型，再进行比较

详细为这个图：

<img src="/Users/zoriswang/Desktop/屏幕快照 2021-01-25 下午4.02.15.png" alt="屏幕快照 2021-01-25 下午4.02.15" style="zoom:40%;" />

结果：

|            表达式             | 类   型 | 求   值 |
| :---------------------------: | :-----: | :-----: |
| -2147483647-1 == 2147483648U  | 无符号  |    1    |
|  -2147483647-1 < 2147483647   | 有符号  |    1    |
|  -2147483647-1U < 2147483647  | 无符号  |    0    |
| -2147483647-1  <  -2147483647 | 有符号  |    1    |
|  -2147483647-1U<-2147483647   | 无符号  |    0    |

## 2.22 补码扩展

这个是用来说明`当补码扩展的是符号位`时，值不变

## 2.23 右移结果

> 因为系统目前为mac 10.12.6，在这里给出的程序结果为逻辑移位，如果不是，跟我说一下吧qwq

**程序：**

```c
    while(1){
        int x;
        scanf("%x", &x);
        printf("fun1: %.8x\n", fun1(x));
        printf("fun2: %.8x\n", fun2(x));
    }
```

**结果：**

```bash
0x87654321
fun1: 00000021
fun2: 00000021
0x00000076
fun1: 00000076
fun2: 00000076
0x00000C9
fun1: 000000c9
fun2: ffffffc9
0XEDCBA987
fun1: 00000087
fun2: ffffff87
```

## 2.24 截断情况

### <1> 如何截断呢？

#### 1. 无符号数

截断：`11011` (27)--> `1011`(11) : $27mod\ 2^4$ ,4来源于最高位`4 3 2 1 0`

总结为：无符号数截断数---num%$2^k$(k为最高位)

#### 2. 有符号数（补码）

（我自己感觉的最简单的方法）

截断: `10011`(-13) -->截断数则为$-13+2^4 = 3$，则截断数为`0011`

总结为：补码截断数---num+2^k次位后，转截断一位得数，如果是0，则能够视为**无符号数**处理

### <2> Result

> 原数为4位，现在需要截断到3位

|   无符号   |            |  补   码   |            |
| :--------: | :--------: | :--------: | :--------: |
| **原始值** | **截断值** | **原始值** | **截断值** |
|     0      |     0      |     0      |     0      |
|     2      |     2      |     2      |     2      |
|     9      |     1      |     -7     |     1      |
|     11     |     3      |     -5     |     3      |
|     15     |     7      |     -1     |     7      |

## 2.25 unsigned的bug

研究的函数为：

```c
float sum_elements(float a[], unsigned len){
    int i;
    float result = 0;
    for(int i=0; i<=len-1; ++i){
        result+=a[i];
    }
    return result;
}
```

> 当len=0时，报错为：

```bash
(interrupted by signal 11: SIGSEGV)
```

因为len为unsigned型，当变为-1时，其实又会转为4294967295，这么加，会导致循环一直难以停下来

修改：将`unsigned`改为`int`,`15-213`上提过如何用unsigned改，但我觉得太反逻辑了，就没有记下来，感兴趣的朋友可以看看lec3这一块

## 2.26 unsigned 类型运算的bug

- **A:** 当`s.length > t.length`的时候，结果会不准确
- **B:** 因为数据类型为无符号型，无符号是不会有负数存在的，所以当s的长度小于t时，返回的会一直是1
- **C:** 修改为`return s.length>t.length`即可



