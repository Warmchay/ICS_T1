# Appendix: Machine-level programming Q&A

> [基本汇编指令详解](http://blog.luoyuanhang.com/2015/07/07/%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/)
>
> 栈地址大小： 栈底（%ebp）高地址栈顶(%esp)低地址。栈向下增长，压栈操作使栈顶地址减小，出栈操作使栈顶地址增大![image-20210215142706708](/Users/zoriswang/Library/Application Support/typora-user-images/image-20210215142706708.png)

## 1⃣️ Data alignment

> 实质： 内存字节的对齐

### 1.1 concept

- 内存空间按照byte划分，理论上：任何类型的变量的访问能够从任何地址开始，**实际上：**访问特定变量时需要在特定的内存地址访问。<font color=red>**因此需要各类型数据按照一定规则在空间上排列，而不是顺序的一个接一个的排放。**</font>这就是对齐。
- **访问数据的地址要满足一定条件**

> E.G: 1byte 数据已经对齐， 2 bytes 数据地址需要能被2整除，4 bytes 数据地址需要能呗4整除

- 数据对齐不属于os的内存结构，而是cpu结构的一部分
- 当cpu访问正确对齐的数据时，运行效率最高。当cpu读取的数据没有对齐时，进行两种操作：
  - 产生一个异常条件，IA32中默认行为是**程序终止**
  - 执行多次对齐的内存访问，来读取完整的未对齐的数据值

### 1.2 reasons for aligning

1. 使各个平台上关于数据的读取方式达成一致，提高读取效率
2. 现代存储系统采用许多并行的存储芯片来提高读取效率

### 1.3 how to get aligned

> 一般情况下，complier会自动选择合适目标平台的对齐策略。但我们也能够通知给complier传递预编译指令来改变对指定数据的对齐方法

1. 数据在内存中实现对齐的过程：[内存字节对齐详解](https://blog.csdn.net/arethe/article/details/2548867)

2. 数据对齐实现的两种方式：

   1. **自然对齐（默认对齐**

   一般编译器的对齐位默认都为8位，为**数据类型两两之间的对齐**，若两个都是同类型，直到下一个数据类型大于它们的byte时，都相加需要达到的位数。举个栗子：

   ```c
   struct A{
   	char c1;
     long l1;
     char c2;
     double d1;
   }
   struct B{
     char c1;
     char c2;
     long l1;
     double d1;
   }
   
   /*size: A: 32  B: 24*/
   ```

   sizeof(A): $(1+3)+4+(1+7)+8 = 32$

   sizeof(B): $(1+3)+(1+3)+(4+4)+8 = 24$

   **summary：** 各成员变量存放的地址相对于结构的其实地址的偏移量位sizeof（类型）的整数倍，结构体大小一般是最大类型的sizeof（类型）的整数倍。**因此在定义结构体时按照类型大小从小到大声明，来减少中间的填补空间。**

   2. **强制对齐（人为修改**

   > 使用#pragma pack(VALUE)中value值来修改

   举个栗子：

   ```c
   #pragma value(4)
   struct A{
     char c1;
     long l1;
     char c2;
     double d1
   }
   
   /*sizeof(A): (1+3)+4+(1+3)+8 = 20*/
   ```

   (1+3): 强制对齐的$4 = value < double = 8$，8为c2的自身对齐值

   **summary：** 若强制对齐值n大于等于自身对齐值，偏移量满足自然对齐方式，若n小于自身对齐值，那么不用满足默认的对齐方式 

## 2⃣️ Pointer Again

- **每个指针都有一个值。**该值为某个指定类型对象的地址，而null || 0表示该指针没有指向任何地方
- **指针用&运算符创建。** 
- ***表示间接引用指针。** 通过存储器引用来实现，要么存储到一个指定的地址，要么是从特定的地址中读取
- **指针间进行类型转换时，只改变它的类型，不改变它的值**
- **指针也可以指向函数。** 举个栗子：

```c
int fun(int x, int *p);

int (*fp)(int, int *);
fp = fun;
/*调用*/
int y = 1;
int result = (3, &y);
```

## 3⃣️ 内存越界引用和缓冲区溢出

### 3.1 缓冲区溢出

> 典型的不用`gets`

因为c对于数组引用不进行任何的边界检查，局部变量和状态信息都存放于栈中，这两种情况结合在一起会造成程序错误，而越界的数组元素的写操作可能会破坏栈中的状态信息。

如当gets输入的字符串大于限定的字符空间时，以下信息会被破坏，假设字符数组为`buf[8]`。

| 输入字符数量 | 附加的被破坏的状态 |
| :----------: | :----------------: |
|     0-7      |         无         |
|     8-11     |   保存的%ebx的值   |
|    12-15     |   保存的%ebp的值   |
|    16-19     |      返回地址      |
|     20+      | caller中保存的状态 |

可以看出，当缓冲区溢出时会让程序执行它本来不愿意执行的函数，这一般为计算机网络攻击系统安全的方法。

如，输入给程序一个字符串，该字符串包含一些可执行代码的字节编码，成为攻击代码（exploit code）；另外还会有一些字节会用一个指向攻击代码的指针覆盖返回地址，使程序执行ret指令后跳转到攻击代码。

### 3.2 对抗缓冲区溢出攻击

> 这些方法限制了入侵者通过缓冲区溢出攻击而获得系统控制

#### 3.2.1 栈随机化

攻击者在系统中插入攻击代码，既要插入代码，也要插入这段代码的指针，这个指针是攻击字符串的一部分，产生这个指针需要知道字符串放置的栈的地址。

**栈随机化**即是让程序在每次运行时都会有变化，如此即使许多机器都在运行同样的代码，但是他们的栈地址是不同的。在Linux中成为地址空间布局随机化（Address-Space Layout Randomization）ASLR。

采用ASLR，会使每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域，意味着一台机器上运行一个程序，与其他机器上运行相同的程序，地址映射大相径庭

#### 3.2.2 栈破坏检测

> 加入金丝雀（canary）值，也称为哨兵值（guard value）
>
> Quotation: canary used to check whether the gas is toxic~

思想：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值，每次运行时随机产生，在恢复寄存器状态和和从函数返回之前，程序会检查金丝雀值是否改变，如果改变，程序异常终止。

如指令参数`%fs:40`指明金丝雀值使用段寻址从内存中都如的，段寻址机制可以追溯到80286的寻址，将金丝雀值存放在一个只读的特殊段中，避免了攻击者覆盖存储的金丝雀值。在恢复寄存器状态和返回前，函数将存储在栈未知的值与金丝雀值比较，若值相同，函数按照正常方式完成，反之异常终止

```bash
xorq %fs:40,%rax          ; compare to stored value
```

> 金丝雀值通过存储应该返回的正确值来判别是否继续执行

#### 3.2.3 限制可执行代码区域

阻止攻击者向系统中插入可执行代码

**限制可以存放可执行代码的区域**，程序中只有保存complier保存代码部分的内存是可以执行的，其他部分被限制为只允许读和写，虚拟内存空间在逻辑上被划分为page，each page has `2048bytes`or`4096bytes`.

系统允许控制三种访问形式：

- 读： 从内存读数据
- 写：存储数据到内存
- 执行：将内存中的内容视为机器级代码

目前，程序处理器的内存保护模式为：在内存中引入“NX”(No-excute)不执行为，将读和执行访问模式分开。基于该特性，栈可以被标记为可读可写，但是不能够执行，而检查page是否可以执行由硬件完成，效率上没有产生损失。

