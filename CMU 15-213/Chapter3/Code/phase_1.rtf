{\rtf1\ansi\ansicpg936\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww19700\viewh13440\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 phase
\f1\fs24 \cf0 \CocoaLigature1 _1 requests:\
- string_length\
- strings_not_equal\

\f0\fs22 \cf2 \CocoaLigature0 \
					\'97-string_length \'97\'97-\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f2\b string_length:\

\f0\b0   40131b:	80 3f 00 	cmpb	$0, (%rdi)\
  40131e:	74 12 	je	18 <string_length+0x17>\
  401320:	48 89 fa 	movq	%rdi, %rdx\
  401323:	48 83 c2 01 	addq	$1, %rdx\
  401327:	89 d0 	movl	%edx, %eax\
  401329:	29 f8 	subl	%edi, %eax\
  40132b:	80 3a 00 	cmpb	$0, (%rdx)\
  40132e:	75 f3 	jne	-13 <string_length+0x8>\
  401330:	f3 c3 	rep		retq\
  401332:	b8 00 00 00 00 	movl	$0, %eax\
  401337:	c3 	retq\
					\'97-strings_not_equal\'97\'97\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f2\b strings_not_equal:
\f0\b0 \
  401338:	41 54 	pushq	%r12\
  40133a:	55 	pushq	%rbp\
  40133b:	53 	pushq	%rbx\
  40133c:	48 89 fb 	movq	%rdi, %rbx\
  40133f:	48 89 f5 	movq	%rsi, %rbp\
  401342:	e8 d4 ff ff ff 	callq	-44 <string_length>\
  401347:	41 89 c4 	movl	%eax, %r12d\
  40134a:	48 89 ef 	movq	%rbp, %rdi \
  40134d:	e8 c9 ff ff ff 	callq	-55 <string_length>\
  401352:	ba 01 00 00 00 	movl	$1, %edx\
  401357:	41 39 c4 	cmpl	%eax, %r12d \
  40135a:	75 3f 	jne	63 <strings_not_equal+0x63>\
  40135c:	0f b6 03 	movzbl	(%rbx), %eax\
  40135f:	84 c0 	testb	%al, %al\
  401361:	74 25 	je	37 <strings_not_equal+0x50>\
  401363:	3a 45 00 	cmpb	(%rbp), %al\
  401366:	74 0a 	je	10 <strings_not_equal+0x3a>\
  401368:	eb 25 	jmp	37 <strings_not_equal+0x57>\
  40136a:	3a 45 00 	cmpb	(%rbp), %al\
  40136d:	0f 1f 00 	nopl	(%rax)\
  401370:	75 24 	jne	36 <strings_not_equal+0x5e>\
  401372:	48 83 c3 01 	addq	$1, %rbx\
  401376:	48 83 c5 01 	addq	$1, %rbp\
  40137a:	0f b6 03 	movzbl	(%rbx), %eax\
  40137d:	84 c0 	testb	%al, %al\
  40137f:	75 e9 	jne	-23 <strings_not_equal+0x32>\
  401381:	ba 00 00 00 00 	movl	$0, %edx\
  401386:	eb 13 	jmp	19 <strings_not_equal+0x63>\
  401388:	ba 00 00 00 00 	movl	$0, %edx\
  40138d:	eb 0c 	jmp	12 <strings_not_equal+0x63>\
  40138f:	ba 01 00 00 00 	movl	$1, %edx\
  401394:	eb 05 	jmp	5 <strings_not_equal+0x63>\
  401396:	ba 01 00 00 00 	movl	$1, %edx\
  40139b:	89 d0 	movl	%edx, %eax\
  40139d:	5b 	popq	%rbx\
  40139e:	5d 	popq	%rbp\
  40139f:	41 5c 	popq	%r12\
  4013a1:	c3 	retq\
						-\'97\'97phase_1\'97\'97-\

\f2\b 0000000000400ee0 <phase_1>
\f0\b0 :\
  400ee0:	48 83 ec 08          	sub    $0x8,%rsp\
  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi\
  400ee9:	e8 4a 04 00 00       	callq  401338 <strings_not_equal>\
  400eee:	85 c0                	test   %eax,%eax\
  400ef0:	74 05                	je     400ef7 <phase_1+0x17>\
  400ef2:	e8 43 05 00 00       	callq  40143a <explode_bomb>\
  400ef7:	48 83 c4 08          	add    $0x8,%rsp\
  400efb:	c3                   	retq  \
\
					 \'97\'97\'97\'97phase_1 analysis\'97\'97\'97\
<row by row>\
1. %rsp-8 \'97> 
\f3 Allocate stack frame \'b7\'d6\'c5\'e4\'d5\'bb\'d6\'a1\
2.  Move $402400 to %esi \'a1\'aa> 2nd(?) variable register\
3.  Call <strings_not_equal>, test ret  whether is 0.If ok, je(jump equal) to <phase_1+0x17>(400ef7)\
> `400ee0` is the prior addr of phase_1\
4.  If not, call <explode_bomb>\
5.  %rsp+8, recover stack frame\
6.  Ret\
>>>>>>>>>>>>>>>>>>>>>>>>>>>key: ret value of <
\f0 strings_not_equal
\f3 > \

\f0 				  \'97\'97\'97\'97strings_not_equal analysis\'97\'97\'97\
>>>>>>>>>>>>>>>>key: we have put the 2nd variable in %esi of $4203520\
>>>>>>>>>>>>>>>>so we just watch this register\'92s changes\
<row by row>\
Premise:  %rsi(%esi) == $402400 \
1. %rbx = %rdi: $402400       because %rdi is the 1st argument of reg\
2. %rbp = %rsi: $402400       frame pointer 
\f3 \'d6\'a1\'d6\'b8\'d5\'eb
\f0 \
3. Call <string_length>\
4. %r12d = %eax				 store the return value of %r12d\
5. %rdi = %rbp:$402400\
6. call <string_length>\
7. %edx = $1\
8. Cmpl %eax ?= %r12d \
9. Jne\'97>explode               this situation is not we want\
10. movzbl %eax = m[%rbx]\
11. Test %al, %al             %al stores the value of %esi\
12. Je 37<strings_not_equal+0x50>:this is what we want, stop and analyze here\
\
emmmm, actually, we don\'92t need to analyze these. Based on the solution of\
this question, we could know that the problem wants us to compare the value\
of input strings and pre-ordered strings\'92 value.\
So, we just need to examine the value of the position of 402400\'92s value by\
using (gdb) x/s 0x402400, it will show the right answer of \'93Border relations with Canada have never been better.\'94\
}